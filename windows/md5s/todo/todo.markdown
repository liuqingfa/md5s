# 设计模式

******

## 斑驳

# 生产力工具介绍

+ *Vim* - 纯文本 **编辑器**
+ *Markdown* - 纯文本转标记语言 **工具**
+ *S5* - 标准化简单翻页 **显示系统**
+ *Git* - 分布式快速 **版本控制系统**
+ *Batch* - Windows 平台 shell **脚本**

# MD5S

一个由 Markdown 和 S5 组成的实用 **工具**，  
用来动态生成 *网页版的 PPT*，比如当前页面。

+ 文件占地面积极小
+ 页面源码存储，方便扩展
+ 性能基本没有要求
+ 仅依赖浏览器，跨平台
+ 字体、排版不依赖生成器

# 状态模式

当控制一个对象状态转换的条件表达式过于复杂，将其判断的逻辑  
转移到表示不同状态的一系列类当中去，可以把复杂的逻辑简化。

适用于那些对象行为取决于其 **运行状态** 的场合。

具体的做法：  
将特定状态相关的行为局部化，并将不同状态的行为分割，可通过  
定义新的子类来增加状态和转换。也就是把各种状态逻辑转移到子  
类，从而减少了相互间的依赖。

# 状态模式

![状态模式 UML](https://raw.github.com/neo5simple/md5s/master/windows/md5s/pic/State.png "状态模式 UML")

# 状态模式 与 策略模式

![策略模式 UML](https://raw.github.com/neo5simple/md5s/master/windows/md5s/pic/Strategy.png "策略模式 UML")

# 状态模式 与 策略模式

状态模式是基于对象 **内部状态变化** 来控制使用行为。

策略模式通过封装多个算法在 **不同时间** 应用 **不同业务** 。

# 装饰模式

**可动态** 地去扩展一个对象，不必改变原有类文件以及继承关系。  
该模式将该类中的装饰功能移除，简化代码之余，还有效地将类  
的核心职责与装饰功能区分，也避免装饰过程中的逻辑重复。

具体的做法：  
装饰对象包含一个真实的对象引用，并接受客户端的所有请求，  
添加所需扩展后，再将请求转发到真实对象。  

# 装饰模式

![装饰模式 UML](https://raw.github.com/neo5simple/md5s/master/windows/md5s/pic/Decorator.png "装饰模式 UML")

# 装饰模式 与 代理模式

![代理模式 UML](https://raw.github.com/neo5simple/md5s/master/windows/md5s/pic/Proxy.png "代理模式 UML")

# 装饰模式 与 代理模式

装饰模式在 **运行时** 改变类 **自身** 的行为，增加或减少，  
区别于继承类在编译时的扩展 。

代理模为解决类之间的耦合，作为类的 **中间件** 方便复用和  
隐蔽， **编译时** 已经生效 。

